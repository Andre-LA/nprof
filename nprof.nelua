-- inspired by jprof: https://github.com/pfirsich/jprof
require 'vector'
require 'os'
require 'string'
require 'math'

##[[
  NPROF = NPROF or {}
  NPROF.use_colors = NPROF.use_colors or false
  NPROF.scale = NPROF.scale or {x = 1, y = 24}
  NPROF.draw_list = NPROF.draw_list == nil and true or NPROF.draw_list
  NPROF.draw_rects = NPROF.draw_rects == nil and true or NPROF.draw_rects
  NPROF.draw_impl = NPROF.draw_impl == nil and false or NPROF.draw_impl

  if NPROF.draw_impl then
    local di = NPROF.draw_impl
    assert(di == 'raylib' or di == 'tico', "NPROF doesn't support "..di.." implementation")
  end
]]

## local is_drawing = (NPROF.draw_list or NPROF.draw_rects) and NPROF.draw_impl

## if is_drawing then
  ## if NPROF.draw_impl == 'raylib' then
    require 'raylib'
  ## elseif NPROF.draw_impl == 'tico' then
    require 'tico'
  ## end

  ## if NPROF.draw_impl == 'raylib' then
    local Color = Color
    local Vec2 = Vector2
  ## elseif NPROF.draw_impl == 'tico' then
    local Color = tico.Color
    local Vec2 = tico.Vec2
  ## end

  ## if NPROF.use_colors then
    ## if NPROF.draw_impl == 'raylib' then
      local colors: [15]Color = {
        WHITE,
        ORANGE,
        RED,
        GOLD,
        LIME,
        BLUE,
        LIGHTGRAY,
        PINK,
        YELLOW,
        GREEN,
        RAYWHITE,
        SKYBLUE,
        PURPLE,
        BEIGE,
        MAGENTA,
      }
    ## elseif NPROF.draw_impl == 'tico' then
      local colors: [8]Color = {
        tico.WHITE,
        tico.BLACK,
        tico.BLUE,
        tico.RED,
        tico.GREEN,
        tico.GRAY,
        tico.BROWN,
        tico.BG,
      }
    ## end
  ## end
## end



local NProfItem = @record{
  title: stringview,
  level: uinteger,
  start: number,
  _end: number,
}

function NProfItem:__tostring(): string
  return self.title .. ' { start = ' .. self.start .. '; _end = ' .. self._end .. '; level = ' .. self.level .. '}'
end

global NProf = @record{
  recording_stack: vector(NProfItem),
  recorded_stack: vector(NProfItem),
  current_level: uinteger,
  next_recording_idx: uinteger,
  next_recorded_idx: uinteger,
}

function NProf:push(title: stringview)
  ## if PROF then
    self.current_level = self.current_level + 1

    if self.next_recording_idx == #self.recording_stack then
      self.recording_stack:push({})
    end

    self.recording_stack[self.next_recording_idx] = {
      title = title,
      level = self.current_level,
      start = os.clock(),
    }

    self.next_recording_idx = self.next_recording_idx + 1
  ## end
end

function NProf:pop()
  ## if PROF then
    local previous_recording_idx = self.next_recording_idx - 1

    if self.next_recorded_idx == #self.recorded_stack then
      self.recorded_stack:push({})
    end

    self.recorded_stack[self.next_recorded_idx] = self.recording_stack[previous_recording_idx]
    self.recorded_stack[self.next_recorded_idx]._end = os.clock()

    self.next_recorded_idx = self.next_recorded_idx + 1
    self.next_recording_idx = previous_recording_idx
    self.current_level = self.current_level - 1
  ## end
end

function NProf:reset()
  ## if PROF then
    self.recording_stack:destroy()
    self.recorded_stack:destroy()
    self.current_level = 0
    self.next_recording_idx = 0
    self.next_recorded_idx = 0
  ## end
end

function NProf:report(): string
  ## if PROF then
    local result: string = ""

    for i = 0, < self.next_recorded_idx do
      result = result .. tostring(self.recorded_stack[i]) .. '\n'
    end

    return result
  ## else
    return ''
  ## end
end

function NProf:draw()
  ## if PROF and is_drawing then
    local scale_x <comptime> = #[math.abs(NPROF.scale.x)]#
    local scale_y <comptime> = #[NPROF.scale.y]#

    ## if NPROF.draw_impl == 'raylib' then
      local rect_background = BLACK
    ## elseif NPROF.draw_impl == 'tico' then
      local rect_background = tico.BLACK
    ## end

    rect_background.a = 175

    local start_min = math.huge
    local end_max = 0.0

    for i = 0, < #self.recorded_stack do
      local r: *NProfItem = self.recorded_stack[i]

      if r.start < start_min then
        start_min = r.start
      end
      if r._end > end_max then
        end_max = r._end
      end
    end

    for i = 0, < #self.recorded_stack do
      ## if NPROF.draw_impl == 'raylib' then
        local color: Color = WHITE
      ## elseif NPROF.draw_impl == 'tico' then
        local color: Color = tico.WHITE
      ## end

      ## if NPROF.use_colors then
        color = colors[i % #colors]
      ## end

      local item: *NProfItem = self.recorded_stack[i]

      local indentation = string.rep('  ', item.level)
      defer indentation:destroy() end

      local s = (item.start - start_min) / (end_max - start_min)
      local e = (item._end - start_min) / (end_max - start_min)

      local p_str = tostring((e - s) * 100)
      defer p_str:destroy() end

      local percent: stringbuilder;
      percent:write_string(p_str)
      percent:write_string('%')
      defer percent:destroy() end

      ## if NPROF.draw_rects then
        ## if NPROF.draw_impl == 'raylib' then
          local screen_width = Raylib.GetScreenWidth()
          local screen_height = Raylib.GetScreenHeight()
        ## elseif NPROF.draw_impl == 'tico' then
          local screen_width = tico.window_get_width()
          local screen_height = tico.window_get_height()
        ## end

        ## if NPROF.scale.x > 0 then
          local pos_x =  s * (screen_width * scale_x)
          local size_x = e * (screen_width * scale_x) - pos_x
        ## else
          local pos_x = (item.start - start_min) * scale_x
          local size_x = (item._end - item.start) * scale_x
        ## end

        local pos: Vec2 = {
          x = pos_x,
          y = screen_height - item.level * scale_y
        }

        local size: Vec2 = {
          x = size_x,
          y = scale_y
        }


        ## if NPROF.draw_impl == 'raylib' then
          -- draw rectangle
          Raylib.DrawRectangleV(pos, size, rect_background)
          Raylib.DrawRectangleLines(math.floor(pos.x), math.floor(pos.y), math.floor(size.x), math.floor(size.y), color)

          -- draw rectangle texts
          Raylib.DrawText(item.title, math.floor(pos.x + 2), math.floor(pos.y + 2), math.floor(scale_y//2) - 2, color)
          Raylib.DrawText(percent, math.floor(pos.x + 2), math.floor(pos.y + math.floor(scale_y//2) +2), math.floor(scale_y/2) - 2, color)
        ## elseif NPROF.draw_impl == 'tico' then
          -- draw rectangle
          tico.graphics_fill_rectangle(pos.x, pos.y, size.x, size.y, rect_background)
          tico.graphics_draw_rectangle(pos.x, pos.y, math.ifloor(size.x), math.ifloor(size.y), color)

          -- draw rectangle texts
          tico.graphics_draw_text(item.title, math.ifloor(pos.x + 2), math.ifloor(pos.y + 2), color)
          tico.graphics_draw_text(percent, math.ifloor(pos.x + 2), math.ifloor(pos.y + math.ifloor(scale_y/2) + 2), color)
        ## end
      ## end

      -- draw text line
      -- TODO: It draws in an weird order
      ## if NPROF.draw_list then
        local title_p: stringbuilder;
        title_p:write_string(indentation)
        title_p:write_string(item.title)
        title_p:write_string(': ')
        title_p:write_string(percent)
        defer title_p:destroy() end

        ## if NPROF.draw_impl == 'raylib' then
          Raylib.DrawRectangle(10, i*11, title_p.size * 7, 11, rect_background)
          Raylib.DrawText(title_p, 10, i * 11, 10, color)
        ## elseif NPROF.draw_impl == 'tico' then
          tico.graphics_fill_rectangle(10, i*11, title_p.size * 7, 11, rect_background)
          tico.graphics_draw_text(title_p, 10, i * 11, color)
        ## end
      ## end
    end
  ## end
end

## if TEST then
  local nprof: NProf = {}

  nprof:push'first for'
  defer nprof:pop() end

  local x: uinteger, y: uinteger = 0, 0

  for i = 0, 3 do
    nprof:push('second for (' .. i .. ')')
    defer nprof:pop() end

    x, y = x + 1, 0
    for j = 0, 50000000 do
      y = y + 1
    end
  end

  print(nprof:report())
## end
