-- inspired by jprof: https://github.com/pfirsich/jprof
require 'vector'
require 'os'
require 'string'
require 'math'

## NPROF = NPROF or { use_colors = false, scale = {x = 1, y = 24}, draw_list = true, draw_rects  = true}
## NPROF.use_colors = NPROF.use_colors or false
## NPROF.scale = NPROF.scale or {x = 1, y = 24}
## NPROF.draw_list = NPROF.draw_list == nil and true or NPROF.draw_list
## NPROF.draw_rects = NPROF.draw_rects == nil and true or NPROF.draw_rects

## local is_drawing = NPROF.draw_list or NPROF.draw_rects

## if is_drawing then
require 'raylib'
## end

## if NPROF.use_colors and is_drawing then
local colors: [15]Color = {
  WHITE,
  ORANGE,
  RED,
  GOLD,
  LIME,
  BLUE,
  LIGHTGRAY,
  PINK,
  YELLOW,
  GREEN,
  RAYWHITE,
  SKYBLUE,
  PURPLE,
  BEIGE,
  MAGENTA,
}
## end

local NProfItem = @record{
  title: stringview,
  level: uinteger,
  start: number,
  _end: number,
}

function NProfItem:__tostring(): string
  return self.title .. ' { start = ' .. self.start .. '; _end = ' .. self._end .. '; level = ' .. self.level .. '}'
end

global NProf = @record{
  recording_stack: vector(NProfItem),
  recorded_stack: vector(NProfItem),
  current_level: uinteger,
  next_recording_idx: uinteger,
  next_recorded_idx: uinteger,
}

function NProf:push(title: stringview)
  ## if PROF then
    self.current_level = self.current_level + 1

    if self.next_recording_idx == #self.recording_stack then
      self.recording_stack:push({})
    end

    self.recording_stack[self.next_recording_idx] = {
      title = title,
      level = self.current_level,
      start = os.clock(),
    }

    self.next_recording_idx = self.next_recording_idx + 1
  ## end
end

function NProf:pop()
  ## if PROF then
    local previous_recording_idx = self.next_recording_idx - 1

    if self.next_recorded_idx == #self.recorded_stack then
      self.recorded_stack:push({})
    end

    self.recorded_stack[self.next_recorded_idx] = self.recording_stack[previous_recording_idx]
    self.recorded_stack[self.next_recorded_idx]._end = os.clock()

    self.next_recorded_idx = self.next_recorded_idx + 1
    self.next_recording_idx = previous_recording_idx
    self.current_level = self.current_level - 1
  ## end
end

function NProf:reset()
  ## if PROF then
    self.recording_stack:destroy()
    self.recorded_stack:destroy()
    self.current_level = 0
    self.next_recording_idx = 0
    self.next_recorded_idx = 0
  ## end
end

function NProf:report(): string
  ## if PROF then
    local result: string = ""

    for i = 0, < self.next_recorded_idx do
      result = result .. tostring(self.recorded_stack[i]) .. '\n'
    end

    return result
  ## else
    return ''
  ## end
end

function NProf:draw()
  ## if PROF and is_drawing then
    local scale_x <comptime> = #[math.abs(NPROF.scale.x)]#
    local scale_y <comptime> = #[NPROF.scale.y]#

    local rect_background = BLACK
    rect_background.a = 175

    local start_min = math.huge
    local end_max = 0.0

    for i = 0, < #self.recorded_stack do
      local r: *NProfItem = self.recorded_stack[i]

      if r.start < start_min then
        start_min = r.start
      end
      if r._end > end_max then
        end_max = r._end
      end
    end

    for i = 0, < #self.recorded_stack do
      local color: Color = WHITE
      ## if NPROF.use_colors then
        color = colors[i % #colors]
      ## end

      local item: *NProfItem = self.recorded_stack[i]

      local indentation = string.rep('  ', item.level)
      defer indentation:destroy() end

      local s = (item.start - start_min) / (end_max - start_min)
      local e = (item._end - start_min) / (end_max - start_min)

      local p_str = tostring((e - s) * 100)
      defer p_str:destroy() end

      local percent: stringbuilder;
      percent:write_string(p_str)
      percent:write_string('%')
      defer percent:destroy() end

      ## if NPROF.draw_rects then
        ## if NPROF.scale.x > 0 then
        local pos_x =  s * (Raylib.GetScreenWidth() * scale_x)
        local size_x = e * (Raylib.GetScreenWidth() * scale_x) - pos_x
        ## else
        local pos_x = (item.start - start_min) * scale_x
        local size_x = (item._end - item.start) * scale_x
        ## end

        local pos: Vector2 = {
          x = pos_x,
          y = Raylib.GetScreenHeight() - item.level * scale_y
        }

        local size: Vector2 = {
          x = size_x,
          y = scale_y
        }

        -- draw rectangle
        Raylib.DrawRectangleV(pos, size, rect_background)
        Raylib.DrawRectangleLines(math.floor(pos.x), math.floor(pos.y), math.floor(size.x), math.floor(size.y), color)

        -- draw rectangle texts
        Raylib.DrawText(item.title, math.floor(pos.x + 2), math.floor(pos.y + 2), math.floor(scale_y//2) - 2, color)
        Raylib.DrawText(percent, math.floor(pos.x + 2), math.floor(pos.y + math.floor(scale_y//2) +2), math.floor(scale_y/2) - 2, color)
      ## end

      -- draw text line
      -- TODO: It draws in an weird order
      ## if NPROF.draw_list then
        local title_p: stringbuilder;
        title_p:write_string(indentation)
        title_p:write_string(item.title)
        title_p:write_string(': ')
        title_p:write_string(percent)
        defer title_p:destroy() end

        Raylib.DrawRectangle(10, i*11, title_p.size * 7, 11, rect_background)
        Raylib.DrawText(title_p, 10, i * 11, 10, color)
      ## end
    end
  ## end
end

## if TEST then
  local nprof: NProf = {}

  nprof:push'first for'
  defer nprof:pop() end

  local x: uinteger, y: uinteger = 0, 0

  for i = 0, 3 do
    nprof:push('second for (' .. i .. ')')
    defer nprof:pop() end

    x, y = x + 1, 0
    for j = 0, 50000000 do
      y = y + 1
    end
  end

  print(nprof:report())
## end
